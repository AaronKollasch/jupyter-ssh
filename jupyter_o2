#!/usr/bin/env python
# -*- coding: utf-8 -*-
# author: Aaron Kollasch
# date: 2017-12-12
"""A script to launch and connect to a Jupyter session on Orchestra 2.
as described at https://wiki.rc.hms.harvard.edu/display/O2/Jupyter+on+O2

Usage: jupyter_o2 <USER> <subcommand>

Example: jupyter_o2 js123 notebook
    This will launch an X11-enabled ssh, start an interactive node running jupyter notebook,
    ssh into that interactive node to allow requests to be forwarded,
    and finally open the notebook in your browser.

Troubleshooting:
    If jupyter hangs when opening notebooks for the first time in any session,
    and the console shows a "The signatures database cannot be opened" error,
    enter an interactive session and generate a notebook config using
      `jupyter notebook --generate-config`
    then set c.NotebookNotary.db_file = ':memory:'

"""

from __future__ import print_function
import sys
import os
import argparse
import getpass  # fallback if pinentry is not installed (optional "brew install pinentry" on macs)
import subprocess
import re
import webbrowser
import ctypes
import atexit
from signal import signal, SIGABRT, SIGINT, SIGTERM
from pexpect import pxssh
try:
    # optional import of dnspython to resolve "Unknown host" errors
    # if you get errors like "Could not establish connection to host",
    # test the server with nslookup <host>
    # your current DNS server may not have entries for the individual O2 login nodes
    import dns.resolver
except ImportError:
    dns = None

#############################################################
# variables to set                                          #
# choose a DEFAULT_JP_PORT that is open on your machine     #
# and set SOURCE_JUPYTER_CALL to an appropriate command     #
#############################################################

HOST = "o2.hms.harvard.edu"
DEFAULT_JP_PORT = 8887  # pick an open port on your machine
DEFAULT_JP_TIME = "0-12:00"  # 12 hours
DEFAULT_JP_MEM = "1G"
DEFAULT_JP_CORES = 1

# the bash command to enter your jupyter environment (one line, use semicolons if needed)
SOURCE_JUPYTER_CALL = "source ~/.conda/envs/py35/bin/activate py35"

parser = argparse.ArgumentParser(description='Launch and connect to a Jupyter session on O2.')
parser.add_argument("user", type=str, help="O2 username")
parser.add_argument("subcommand", help="the subcommand to launch")
parser.add_argument("-p", "--port", type=int, default=DEFAULT_JP_PORT, help="Available port on your system")
parser.add_argument("-t", "--time", type=str, default=DEFAULT_JP_TIME, help="Time to run Jupyter")
parser.add_argument("-m", "--mem", type=str, default=DEFAULT_JP_MEM, help="Memory to allocate for Jupyter")
parser.add_argument("-c", "-n", dest="cores", type=int, default=DEFAULT_JP_CORES, help="Cores to allocate for Jupyter")
parser.add_argument("-k", "--keepalive",  default=False, action='store_true',
                    help="Keep interactive session alive after exiting Jupyter")
pargs = parser.parse_args(sys.argv[1:])

user = pargs.user
host = HOST
jp_port = pargs.port

srun_call = "srun -t {} --mem {} -n {} --pty -p interactive --x11 /bin/bash".format(pargs.time, pargs.mem, pargs.cores)
jp_call = "jupyter {} --port={} --browser='none'".format(pargs.subcommand, jp_port)

if sys.platform.startswith("linux"):
    my_pinentry_path = "/usr/bin/pinentry"
elif sys.platform == "darwin":
    my_pinentry_path = "/usr/local/bin/pinentry"
else:
    my_pinentry_path = "pinentry"

if dns is not None:
    my_resolver = dns.resolver.Resolver()
    dns_server_groups = [  # dns servers that have entries for loginXX.o2.rc.hms.harvard.edu
        my_resolver.nameservers,                                # current nameservers, checked first
        ["134.174.17.6", "134.174.141.2"],                      # HMS nameservers
        ["128.103.1.1", "128.103.201.100", "128.103.200.101"]   # HU nameservers
    ]
    # test that you can access the login nodes with nslookup login01.o2.rc.hms.harvard.edu <DNS>
else:
    my_resolver = None
    dns_server_groups = None

if sys.version_info.major == 3:
    stdout_buffer = sys.stdout.buffer
else:
    stdout_buffer = sys.stdout


#####################################################
# functions and classes                             #
#####################################################


def check_dns(hostname, dns_groups=dns_server_groups):
    """Check if hostname is reachable by any group of dns servers."""
    if dns is not None:
        dns_err_code = 0
        for dns_servers in dns_groups:
            try:
                my_resolver.nameservers = dns_servers
                if dns_err_code > 0:
                    eprint("Could not resolve domain. Trying with nameservers: {}".format(dns_servers))
                    answer = my_resolver.query(hostname)
                    hostname = answer[0].address
                    dns_err_code = 1
                else:
                    my_resolver.query(hostname)
                break
            except dns.resolver.NXDOMAIN:
                dns_err_code = 2
    else:
        dns_err_code = -1
    if dns_err_code == 1:
        print("Found IP: {}".format(jp_login_host))
    elif dns_err_code == 2:
        eprint("No IP found for {}".format(jp_login_host))
    return dns_err_code, hostname


class CustomSSH(pxssh.pxssh):
    def silence_logs(self):
        """Prevent printing into any logfile."""
        self.logfile = None
        self.logfile_read = None
        self.logfile_send = None

    def digest_all_prompts(self, timeout=0.5):
        """Digest all prompts until there is a delay of <timeout>."""
        if timeout == -1:
            timeout = self.timeout
        while self.prompt(timeout):
            pass


class FilteredOut(object):
    def __init__(self, txtctrl, by):
        self.txtctrl = txtctrl
        self.by = by

    def write(self, bytestr):
        try:
            if bytestr[:len(self.by)] == self.by:
                self.txtctrl.write(bytestr)
        except IndexError:
            pass

    def flush(self):
        self.txtctrl.flush()

    def exit_on_find(self, bytestr):
        if self.by in bytestr:
            sys.exit(0)
        return bytestr


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def clean(*_):
    print("Cleaning up\r")
    if "o2_pass" in globals():
        zero(o2_pass)
    if "pinentry" in globals():
        pinentry.close()
    if "login_ssh" in globals():
        if not login_ssh.closed:
            print("Closing login_ssh")
        login_ssh.close(force=True)
    if "second_ssh" in globals():
        if not second_ssh.closed:
            print("Closing second_ssh")
        login_ssh.close(force=True)


def term(*_):
    clean()
    sys.stdout.close()
    sys.stderr.close()
    sys.stdin.close()
    os.closerange(0, 3)
    os._exit(1)


# perform clean() on exit or interrupt
atexit.register(clean)
for sig in (SIGABRT, SIGINT, SIGTERM):
    signal(sig, term)


#####################################################################
# pin entry and security functions from pysectools                  #
#                                                                   #
# updated pysectools for python 3:                                  #
#   uses bytestrings and flushes stdin after writing                #
#                                                                   #
# slightly modified from Greg V:                                    #
# Copyright Â© 2013-2015 Greg V <greg@unrelenting.technology>        #
# This work is free. You can redistribute it and/or modify it       #
# under the terms of the                                            #
# Do What The Fuck You Want To Public License, Version 2,           #
# as published by Sam Hocevar.                                      #
#####################################################################


def zero(s):
    """
    Tries to securely erase a secret string from memory
    (overwrite it with zeros.)

    Only works on CPython.

    Returns True if successful, False otherwise.
    """
    try:
        bufsize = len(s) + 1
        offset = sys.getsizeof(s) - bufsize
        location = id(s) + offset
        ctypes.memset(location, 0, bufsize)
        return True
    except:
        return False


def cmd_exists(cmd):
    return subprocess.call("type " + cmd, shell=True,
                           stdout=subprocess.PIPE, stderr=subprocess.PIPE) == 0


class PinentryException(Exception):
    pass


class PinentryUnavailableException(PinentryException):
    pass


class PinentryClosedException(PinentryException):
    pass


class PinentryErrorException(PinentryException):
    pass


class Pinentry(object):
    def __init__(self, pinentry_path="pinentry", fallback_to_getpass=True):
        if not cmd_exists(pinentry_path):
            if fallback_to_getpass and os.isatty(sys.stdout.fileno()):
                self._ask = self._ask_with_getpass
                self._close = self._close_getpass
            else:
                raise PinentryUnavailableException()
        else:
            self.process = subprocess.Popen(pinentry_path,
                                            stdin=subprocess.PIPE,
                                            stdout=subprocess.PIPE,
                                            stderr=subprocess.STDOUT,
                                            close_fds=True)
            self._ask = self._ask_with_pinentry
            self._close = self._close_pinentry
        self._closed = False

    def ask(self,
            prompt="Enter the password: ",
            description=None,
            error="Wrong password!",
            validator=lambda x: x is not None):
        if self._closed:
            raise PinentryClosedException()
        return self._ask(prompt, description, error, validator)

    def close(self):
        self._closed = True
        return self._close()

    @staticmethod
    def _ask_with_getpass(prompt, description, error, validator):
        if description:
            print(description)
        password = None
        while not validator(password):
            if password is not None:
                print(error)
            password = getpass.getpass(prompt)
        return password

    def _close_getpass(self): pass

    def _ask_with_pinentry(self, prompt, description, error, validator):
        self._waitfor("OK")
        env = os.environ.get
        self._comm("OPTION lc-ctype=%s" % env("LC_CTYPE", env("LC_ALL", "en_US.UTF-8")))
        try:
            self._comm("OPTION ttyname=%s" % env("TTY", os.ttyname(sys.stdout.fileno())))
        except:
            pass
        if env('TERM'):
            self._comm("OPTION ttytype=%s" % env("TERM"))
        if prompt:
            self._comm("SETPROMPT %s" % self._esc(prompt))
        if description:
            self._comm("SETDESC %s" % self._esc(description))
        password = None
        while not validator(password):
            if password is not None:
                self._comm("SETERROR %s" % self._esc(error))
            self.process.stdin.write(b"GETPIN\n")
            self.process.stdin.flush()
            try:
                password = self._waitfor("D ", breakat="OK", errat="ERR")
            except PinentryErrorException:
                sys.exit(0)
            if password is not None:
                password = password[2:].replace("\n", "")
        return password

    def _close_pinentry(self):
        return self.process.kill()

    def _waitfor(self, what, breakat=None, errat=None):
        out = ""
        while not out.startswith(what):
            if breakat is not None and out.startswith(breakat):
                break
            elif errat is not None and out.startswith(errat):
                raise PinentryErrorException()
            out = self.process.stdout.readline().decode('utf-8')
        return out

    def _comm(self, x):
        self.process.stdin.write(x.encode('utf-8') + b"\n")
        self.process.stdin.flush()
        self._waitfor("OK")

    @staticmethod
    def _esc(x):
        return x.replace("%", "%25").replace("\n", "%0A")


#############################################################
#   Now run SSH                                             #
#   First SSH into an interactive node and run jupyter.     #
#   Then SSH into that node to set up forwarding.           #
#   Finally, open the jupyter page in the browser.          #
#############################################################

pinentry = Pinentry(pinentry_path=my_pinentry_path, fallback_to_getpass=True)
o2_pass = pinentry.ask(prompt="Enter your passphrase: ",
                       description="Connect to O2 server for jupyter {}".format(pargs.subcommand),
                       error="No password entered", validator=lambda x: x is not None and len(x) > 0)
pinentry.close()

# start login ssh
print("ssh {}@{}".format(user, host))
dns_err, host = check_dns(host)
if dns_err == 1:
    print("ssh {}@{}".format(user, host))
elif dns_err == 2:
    sys.exit(1)
login_ssh = CustomSSH(timeout=60, ignore_sighup=False, options={
    "ForwardX11": "yes",
    "LocalForward": "{} 127.0.0.1:{}".format(jp_port, jp_port),
    "PubkeyAuthentication": "no"})
login_ssh.force_password = True
login_ssh.silence_logs()
login_ssh.login(host, user, o2_pass)

# get the login hostname
login_ssh.sendline("hostname")
login_ssh.prompt()
jp_login_host = login_ssh.before.decode('utf-8').strip().split('\n')[1]
print("hostname: {}".format(jp_login_host))

# enter an interactive session
print()
# print("\nsrun -t 0-3:00 --pty -p interactive --x11 /bin/bash")
pass_pat = re.compile(b"[\w-]+@[\w-]+'s password: ")  # e.g. "user@compute-e-16-175's password: "
login_ssh.PROMPT = pass_pat
login_ssh.logfile_read = FilteredOut(stdout_buffer, b'srun')
login_ssh.sendline(srun_call)
if not login_ssh.prompt():
    eprint("the timeout was reached.")
    sys.exit(1)
login_ssh.silence_logs()
login_ssh.sendline(o2_pass)

# within interactive: get the name of the interactive node
login_ssh.PROMPT = login_ssh.UNIQUE_PROMPT
login_ssh.sendline("unset PROMPT_COMMAND; PS1='[PEXPECT]\$ '")
login_ssh.prompt()
login_ssh.sendline("hostname | sed 's/\..*//'")
login_ssh.prompt()
jp_interactive_host = login_ssh.before.decode('utf-8').strip().split('\n')[1]
print("interactive node: {}\n".format(jp_interactive_host))

# start jupyter
# print("\njupyter notebook --port={} --browser='none'".format(jp_port))
login_ssh.sendline(SOURCE_JUPYTER_CALL)
login_ssh.prompt()
login_ssh.sendline(jp_call)
login_ssh.logfile_read = stdout_buffer

# get the address jupyter is running at
site_pat = re.compile("\s(https?://((localhost)|(127\.0\.0\.1)):{}[\w\-./%?=]+)\s".format(jp_port).encode('utf-8'))
login_ssh.PROMPT = site_pat
if not login_ssh.prompt(10):  # timed out; failed to launch jupyter
    if pargs.keepalive:
        interact_filter = FilteredOut(None, b'[PEXPECT]$ logout')  # exits when you log out of the login shell
        login_ssh.interact(output_filter=interact_filter.exit_on_find)
    else:
        eprint("failed to launch jupyter.")
        sys.exit(1)
jp_site = login_ssh.after.decode('utf-8').strip()

# log in to the second ssh
print("\nssh {}@{}".format(user, jp_login_host))
dns_err, jp_login_host = check_dns(jp_login_host)
if dns_err == 1:
    print("ssh {}@{}".format(user, jp_login_host))
elif dns_err == 2:
    sys.exit(1)
second_ssh = CustomSSH(timeout=10, ignore_sighup=False, options={"PubkeyAuthentication": "no"})
second_ssh.force_password = True
second_ssh.silence_logs()
second_ssh.login(jp_login_host, user, o2_pass)

# ssh into the running interactive node
print("\nssh -N -L {0}:127.0.0.1:{0} {1}".format(jp_port, jp_interactive_host))
second_ssh.PROMPT = pass_pat
second_ssh.sendline("ssh -N -L {0}:127.0.0.1:{0} {1}".format(jp_port, jp_interactive_host))
if not second_ssh.prompt():
    eprint("the timeout was reached.")
    sys.exit(1)
second_ssh.silence_logs()
second_ssh.sendline(o2_pass)
zero(o2_pass)  # password is not needed anymore
second_ssh.logfile_read = stdout_buffer  # print any errors/output from second_ssh to stdout

# open Jupyter in browser
print("\nJupyter is ready! Access at:\n{}\nOpening in browser...".format(jp_site))
webbrowser.open(jp_site, new=2)

# keep the ssh session alive and allow input such as Ctrl-C to close Jupyter
login_ssh.silence_logs()
if pargs.keepalive:
    interact_filter = FilteredOut(None, b'[PEXPECT]$ logout')  # exits when you log out of the login shell
    login_ssh.interact(output_filter=interact_filter.exit_on_find)
else:
    interact_filter = FilteredOut(None, b'[PEXPECT]$ ')
    login_ssh.interact(output_filter=interact_filter.exit_on_find)  # exits when jupyter exits and [PEXPECT]$ appears
